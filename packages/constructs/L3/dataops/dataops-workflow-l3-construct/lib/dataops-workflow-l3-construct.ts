/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

import { DataOpsProjectUtils } from '@aws-mdaa/dataops-project-l3-construct';
import { EventBridgeHelper, EventBridgeProps } from '@aws-mdaa/eventbridge-helper';
import { MdaaRole } from '@aws-mdaa/iam-constructs';
import { MdaaKmsKey, IMdaaKmsKey } from '@aws-mdaa/kms-constructs';
import { MdaaL3Construct, MdaaL3ConstructProps } from '@aws-mdaa/l3-construct';
import { Duration } from 'aws-cdk-lib';
import { IRule, IRuleTarget, RuleTargetConfig, RuleTargetInput } from 'aws-cdk-lib/aws-events';
import { TargetBaseProps } from 'aws-cdk-lib/aws-events-targets';
import { CfnTrigger, CfnWorkflow } from 'aws-cdk-lib/aws-glue';
import { Effect, IRole, ManagedPolicy, PolicyStatement, ServicePrincipal } from 'aws-cdk-lib/aws-iam';
import { Construct } from 'constructs';

export interface WorkflowProps {
    /**
     * Workflow defintion as generated by aws cli
     */
    readonly rawWorkflowDef: { [ key: string ]: any }
    /**
     * EventBridge props
     */
    readonly eventBridge?: EventBridgeProps
}

export interface GlueWorkflowL3ConstructProps extends MdaaL3ConstructProps {
    /**
     * The Kms key which will be used to encrypt resources
     */
    readonly kmsArn: string;
    /**
     * The Workflow Definition.
     */
    readonly workflowDefinitions: WorkflowProps[];
    /**
     * The name of the security configuration to be used for the workflow
     */
    readonly securityConfigurationName: string;
    /**
     * The name of the dataops project 
     */
    readonly projectName: string;
}
/**
 * Customize the Lambda Event Target
 */
export interface GlueWorkflowTargetProps extends TargetBaseProps {
    /**
    * The triggering event
     */
    readonly input?: RuleTargetInput;
    /**
     * The workflow to trigger
     */
    readonly workflowArn: string
    /**
     * The role with which to trigger the workflow
     */
    readonly role: IRole
}

export class GlueWorkflowTarget implements IRuleTarget {

    private props: GlueWorkflowTargetProps

    constructor( props: GlueWorkflowTargetProps ) {
        this.props = props
    }

    bind ( _rule: IRule, _id?: string ): RuleTargetConfig {

        const retryPolicy = this.props.maxEventAge || this.props.retryAttempts ? {
            maximumEventAgeInSeconds: this.props.maxEventAge ? this.props.maxEventAge.toSeconds() : undefined,
            maximumRetryAttempts: this.props.retryAttempts
        } : undefined

        return {
            arn: this.props.workflowArn,
            role: this.props.role,
            input: this.props.input,
            deadLetterConfig: {
                arn: this.props.deadLetterQueue?.queueArn,
            },
            retryPolicy: retryPolicy
        }
    }
}

export class GlueWorkflowL3Construct extends MdaaL3Construct {
    protected readonly props: GlueWorkflowL3ConstructProps


    private readonly projectKmsKey: IMdaaKmsKey;
    private readonly projectName: string;

    private eventBridgePolicy?: ManagedPolicy
    private eventBridgeRole?: IRole

    constructor( scope: Construct, id: string, props: GlueWorkflowL3ConstructProps ) {
        super( scope, id, props )
        this.props = props

        this.projectKmsKey = MdaaKmsKey.fromKeyArn( this.scope, "project-kms", this.props.kmsArn )
        this.projectName = this.props.projectName

        // Build our workflows!
        this.props.workflowDefinitions?.map( workflowDefinition => {
            const workflow = this.createWorkflowFromDefinition( workflowDefinition, this.props.securityConfigurationName )
            if ( workflow.name ) {
                const workflowName = workflowDefinition.rawWorkflowDef.Workflow.Name as string
                DataOpsProjectUtils.createProjectSSMParam( this.scope, this.props.naming, this.projectName, `workflow/name/${ workflowName }`, workflow.name )
            }
            return workflow
        } )

    }

    private getEventBridgeRole (): IRole {
        if ( !this.eventBridgeRole ) {
            this.eventBridgeRole = new MdaaRole( this.scope, 'event-bridge-role', {
                naming: this.props.naming,
                roleName: "event-bridge",
                assumedBy: new ServicePrincipal( "events.amazonaws.com" )
            } )
        }
        return this.eventBridgeRole
    }

    private getEventBridgePolicy (): ManagedPolicy {
        if ( !this.eventBridgePolicy ) {
            this.eventBridgePolicy = new ManagedPolicy( this.scope, "event-bridge-policy", {
                managedPolicyName: this.props.naming.resourceName( "event-bridge-policy" ),
                roles: [ this.getEventBridgeRole() ]
            } )
        }
        return this.eventBridgePolicy
    }

    private createWorkflowFromDefinition ( workflowProps: WorkflowProps, securityConfigurationName: string ): CfnWorkflow {

        const workflowName = workflowProps.rawWorkflowDef.Workflow.Name as string
        const workflow = new CfnWorkflow( this.scope, `workflow-${ workflowName }`, {
            defaultRunProperties: workflowProps.rawWorkflowDef.Workflow.DefaultRunProperties,
            description: workflowProps.rawWorkflowDef.Workflow.Description,
            name: this.props.naming.resourceName( workflowName )
        } )

        const graphNodes = workflowProps.rawWorkflowDef.Workflow.Graph.Nodes as { [ key: string ]: any; }[]
        const triggerProps = graphNodes.filter( node => node.Type == "TRIGGER" )

        let previousTriggers: { [ key: string ]: CfnTrigger } = {}
        triggerProps.forEach( triggerProps => {
            const triggerDetails = triggerProps.TriggerDetails.Trigger
            const triggerName = triggerDetails.Name
            const actionsProps = triggerDetails.Actions as { [ key: string ]: any; }[]
            const actions = actionsProps.map( actionProps => this.createActionFromProps( actionProps, securityConfigurationName ) )

            const predicateProps = triggerDetails.Predicate as { [ key: string ]: any; }

            const trigger = new CfnTrigger( this.scope, `trigger-${ workflowName }-${ triggerName }`, {
                name: this.props.naming.resourceName( `${ workflowName }-${ triggerName }` ),
                workflowName: workflow.name,
                actions: actions,
                type: triggerDetails.Type,
                startOnCreation: triggerDetails.State && triggerDetails.State == 'ACTIVATED' ? true : triggerDetails.StartOnCreation,
                predicate: predicateProps ? this.createPredicateFromProps( predicateProps ) : undefined
            } )
            // If Trigger Type is Scheduled, add cron schedule to the trigger
            if ( trigger.type == 'SCHEDULED' ) {
                trigger.schedule = triggerDetails.Schedule
            }
            trigger.addDependency( workflow )

            // Force sequential deployment of Triggers by workflow, otherwise large number 
            // of triggers on a single workflow will cause ConcurrentModificationExceptions.
            if ( previousTriggers[ workflowName ] ) {
                trigger.addDependency( previousTriggers[ workflowName ] )
            }
            previousTriggers[ workflowName ] = trigger
        } )

        if ( workflowProps.eventBridge ) {
            this.createWorkflowEventBridgeRules( workflowProps.eventBridge, workflowName )
        }

        return workflow
    }

    private createWorkflowEventBridgeRules ( eventBridgeProps: EventBridgeProps, workflowName: string ) {

        const workflowResourceName = this.props.naming.resourceName( workflowName )
        const workflowArn = `arn:${ this.partition }:glue:${ this.region }:${ this.account }:workflow/${ workflowResourceName }`
        const triggerFunctionStatement = new PolicyStatement( {
            effect: Effect.ALLOW,
            actions: [
                "glue:notifyEvent"
            ],
            resources: [ workflowArn ]
        } )

        this.getEventBridgePolicy().addStatements( triggerFunctionStatement )

        const dlq = EventBridgeHelper.createDlq( this.scope, this.props.naming, `${ workflowName }-events`, this.projectKmsKey, this.getEventBridgeRole() )
        
        const eventBridgeRuleProps = EventBridgeHelper.createNamedEventBridgeRuleProps( eventBridgeProps, workflowName )

        Object.entries( eventBridgeRuleProps ).forEach( propsEntry => {
            const ruleName = propsEntry[ 0 ]
            const ruleProps = propsEntry[ 1 ]
            const targetProps: GlueWorkflowTargetProps = {
                workflowArn: workflowArn,
                role: this.getEventBridgeRole(),
                deadLetterQueue: dlq,
                retryAttempts: eventBridgeProps.retryAttempts,
                maxEventAge: eventBridgeProps.maxEventAgeSeconds ? Duration.seconds( eventBridgeProps.maxEventAgeSeconds ) : undefined,
                input: RuleTargetInput.fromObject( ruleProps.input ) 
            }

            const target = new GlueWorkflowTarget( targetProps )
            EventBridgeHelper.createEventBridgeRuleForTarget( this.scope, this.props.naming, target, ruleName, ruleProps )
        } )

    }

    protected createPredicateFromProps ( predicateProps: { [ key: string ]: any; } ): CfnTrigger.PredicateProperty {
        const conditionProps = predicateProps.Conditions as { [ key: string ]: any; }[]
        const conditions = conditionProps.map( conditionProps => {
            return {
                crawlerName: conditionProps.CrawlerName,
                crawlState: conditionProps.CrawlState,
                jobName: conditionProps.JobName,
                logicalOperator: conditionProps.LogicalOperator,
                state: conditionProps.State,
            }
        } )
        return {
            logical: predicateProps.Logical,
            conditions: conditions
        }
    }
    protected createActionFromProps ( actionProps: { [ key: string ]: any; }, securityConfigurationName: string ): CfnTrigger.ActionProperty {
        return {
            arguments: actionProps.Arguments,
            crawlerName: actionProps.CrawlerName,
            jobName: actionProps.JobName,
            notificationProperty: {
               notifyDelayAfter : actionProps.NotificationProperty?.NotifyDelayAfter ? actionProps.NotificationProperty.NotifyDelayAfter : actionProps.Timeout,
            },
            securityConfiguration: securityConfigurationName,
            timeout: actionProps.Timeout
        }
    }

}
